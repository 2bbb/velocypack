* fuse types JasonType::String & JasonType::StringLong,
             JasonType::Array & JasonType::ArrayLong,
             JasonType::Object & JasonType::ObjectLong (JS)
  --> done. long types have been removed

* add RapidJson to bench for comparisons (JS)
  --> done, run bench with "rapidjson" as last parameter
  --> TODO: performance tests need to be repeated after refactoring

* compare against TRI_json_t (JS)
  --> done for small.json and sample.json. Jason is 2 to 3 times faster
  --> TODO: performance tests need to be repeated after refactoring

* add pretty printing option to dumper (JS)
  --> done, but needs testing (requires working arrays and objects)

* unify interface of JasonBuffer with interface of std::string (JS)
  --> done

* beat rapidjson!

* add tests for files in jsonSample/ (JS)

* change namespace from triagens::basics to arangodb::jason (JS)

* handle numbers that cannot be represented safely in int64/uint64/double in JasonParser (JS)

* add tests with numeric values +inf, -inf, NaN, INT64_MAX, INT64_MIN etc. (JS)

* finish implementation of JasonSlice for all types (JS)

* handle unsupported JSON types in JasonDumper (JS)

* implement BCD in Builder, Slice, Parser and Dumper

* implement optional lookup table support in Builder, Slice, Parser and Dumper

* test long variants (presumably just use > 255 entries)

* test arrays/objects with few but long elements that exceed 64 KB

* decide if JasonBuffer should be used in JasonBuilder instead of plain std::vector<uint8_t>

* support modification of Jason objects

* optional: support accessing arbitrary objects via JSONPointer etc.

* optional: support for other input encodings (e.g. UTF-16)

* optional: add SSE4 optimization for whitespace parsing (borrow from rapidjson)
